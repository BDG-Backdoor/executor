#include "script_preprocessor.h"
#include <iostream>
#include <sstream>
#include <regex>

namespace RobloxExecutor {
namespace NamingConventions {

// Singleton instance implementation
ScriptPreprocessor& ScriptPreprocessor::GetInstance() {
    static ScriptPreprocessor instance;
    return instance;
}

// Constructor
ScriptPreprocessor::ScriptPreprocessor()
    : m_namingConventionManager(NamingConventionManager::GetInstance()),
      m_functionResolver(FunctionResolver::GetInstance()),
      m_initialized(false) {
}

// Initialize the script preprocessor
bool ScriptPreprocessor::Initialize() {
    if (m_initialized) {
        std::cout << "ScriptPreprocessor: Already initialized" << std::endl;
        return true;
    }
    
    // Make sure the naming convention manager is initialized
    if (!m_namingConventionManager.Initialize()) {
        std::cerr << "ScriptPreprocessor: Failed to initialize naming convention manager" << std::endl;
        return false;
    }
    
    // Make sure the function resolver is initialized
    if (!m_functionResolver.Initialize()) {
        std::cerr << "ScriptPreprocessor: Failed to initialize function resolver" << std::endl;
        return false;
    }
    
    m_initialized = true;
    std::cout << "ScriptPreprocessor: Initialized" << std::endl;
    
    return true;
}

// Preprocess a script to handle naming conventions
std::string ScriptPreprocessor::PreprocessScript(const std::string& script) {
    // Generate compatibility layer for all naming conventions
    std::string compatibilityLayer = GenerateCompatibilityLayer();
    
    // Combine compatibility layer with the script
    return compatibilityLayer + "\n\n" + script;
}

// Generate compatibility layer code for all naming conventions
std::string ScriptPreprocessor::GenerateCompatibilityLayer() {
    std::stringstream compatibilityLayer;
    
    // Add header comment
    compatibilityLayer << "-- Compatibility layer for all naming conventions\n";
    compatibilityLayer << "-- Generated by RobloxExecutor::NamingConventions::ScriptPreprocessor\n\n";
    
    // Add local variables to store original functions
    compatibilityLayer << "-- Store original functions\n";
    compatibilityLayer << "local _originalFunctions = {}\n\n";
    
    // Get all function aliases
    std::vector<FunctionAlias> allAliases = m_namingConventionManager.GetAllAliases();
    
    // Group aliases by original function name
    std::unordered_map<std::string, std::vector<FunctionAlias>> aliasesByOriginal;
    for (const auto& alias : allAliases) {
        aliasesByOriginal[alias.originalName].push_back(alias);
    }
    
    // Generate compatibility layer for each function
    for (const auto& pair : aliasesByOriginal) {
        const std::string& originalName = pair.first;
        const std::vector<FunctionAlias>& aliases = pair.second;
        
        compatibilityLayer << GenerateFunctionCompatibilityLayer(originalName, aliases);
    }
    
    return compatibilityLayer.str();
}

// Generate compatibility layer for a specific function
std::string ScriptPreprocessor::GenerateFunctionCompatibilityLayer(
    const std::string& originalName, const std::vector<FunctionAlias>& aliases) {
    
    std::stringstream code;
    
    // Add comment for the function
    code << "-- Compatibility layer for function '" << originalName << "'\n";
    
    // Store the original function
    code << "_originalFunctions[\"" << originalName << "\"] = " << originalName << "\n";
    
    // Create aliases for the function
    for (const auto& alias : aliases) {
        // Skip the original name
        if (alias.aliasName == originalName) {
            continue;
        }
        
        // Create the alias
        code << alias.aliasName << " = " << originalName << "\n";
    }
    
    code << "\n";
    
    return code.str();
}

// Parse a script to find function calls
std::unordered_set<std::string> ScriptPreprocessor::FindFunctionCalls(const std::string& script) {
    std::unordered_set<std::string> functionCalls;
    
    // Regular expression to match function calls
    // This is a simplified regex and may not catch all cases
    std::regex functionCallRegex(R"((\w+(?:\.\w+)*)\s*\())");
    
    // Find all matches
    auto functionCallBegin = std::sregex_iterator(script.begin(), script.end(), functionCallRegex);
    auto functionCallEnd = std::sregex_iterator();
    
    // Extract function names
    for (std::sregex_iterator i = functionCallBegin; i != functionCallEnd; ++i) {
        std::smatch match = *i;
        std::string functionName = match[1].str();
        functionCalls.insert(functionName);
    }
    
    return functionCalls;
}

} // namespace NamingConventions
} // namespace RobloxExecutor
