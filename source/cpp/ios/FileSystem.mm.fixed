// FileSystem implementation for iOS
#include "FileSystem.h"
#include <fstream>
#include <iostream>
#include <cerrno>
#include <cstring>
#include <sys/stat.h>
#include <dirent.h>

#ifdef __OBJC__
#import <Foundation/Foundation.h>
#endif

namespace iOS {
    // Static member initialization
    std::string FileSystem::m_documentsPath = "";
    std::string FileSystem::m_workspacePath = "";
    std::string FileSystem::m_scriptsPath = "";
    std::string FileSystem::m_logPath = "";
    std::string FileSystem::m_configPath = "";
    bool FileSystem::m_initialized = false;
    
    // Initialize the file system with paths
    bool FileSystem::Initialize(const std::string& appName) {
        if (m_initialized) {
            return true;
        }
        
        try {
            // Get the documents path from iOS
            #ifdef __OBJC__
            NSArray* paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);
            if ([paths count] > 0) {
                NSString* docPath = [paths objectAtIndex:0];
                m_documentsPath = [docPath UTF8String];
            } else {
                return false;
            }
            #else
            // Fallback for non-Objective-C
            m_documentsPath = "/Documents";
            #endif
            
            // Set up the other paths
            m_workspacePath = JoinPaths(m_documentsPath, appName);
            if (!EnsureDirectoryExists(m_workspacePath)) {
                return false;
            }
            
            m_scriptsPath = JoinPaths(m_workspacePath, "Scripts");
            if (!EnsureDirectoryExists(m_scriptsPath)) {
                return false;
            }
            
            m_logPath = JoinPaths(m_workspacePath, "Logs");
            if (!EnsureDirectoryExists(m_logPath)) {
                return false;
            }
            
            m_configPath = JoinPaths(m_workspacePath, "Config");
            if (!EnsureDirectoryExists(m_configPath)) {
                return false;
            }
            
            // Create default files if needed
            if (!CreateDefaultScript()) {
                return false;
            }
            
            if (!CreateDefaultConfig()) {
                return false;
            }
            
            m_initialized = true;
            return true;
        } catch (const std::exception& e) {
            return false;
        }
    }
    
    // Path getters
    std::string FileSystem::GetDocumentsPath() {
        return m_documentsPath;
    }
    
    std::string FileSystem::GetWorkspacePath() {
        return m_workspacePath;
    }
    
    std::string FileSystem::GetScriptsPath() {
        return m_scriptsPath;
    }
    
    std::string FileSystem::GetLogPath() {
        return m_logPath;
    }
    
    std::string FileSystem::GetConfigPath() {
        return m_configPath;
    }
    
    // Directory operations
    bool FileSystem::CreateDirectory(const std::string& path) {
        std::string safePath = SanitizePath(path);
        
        return CreateDirectoryInternal(safePath);
    }
    
    bool FileSystem::CreateDirectoryInternal(const std::string& path) {
        #ifdef __OBJC__
        NSFileManager* fileManager = [NSFileManager defaultManager];
        NSString* nsPath = [NSString stringWithUTF8String:path.c_str()];
        
        NSError* error = nil;
        BOOL success = [fileManager createDirectoryAtPath:nsPath
                                withIntermediateDirectories:YES
                                                 attributes:nil
                                                      error:&error];
        return success;
        #else
        // Simple implementation for non-Objective-C
        return mkdir(path.c_str(), 0755) == 0 || errno == EEXIST;
        #endif
    }
    
    bool FileSystem::EnsureDirectoryExists(const std::string& path) {
        if (Exists(path)) {
            if (GetFileInfo(path).m_type == FileType::Directory) {
                return true;
            }
            // It exists but is not a directory
            return false;
        }
        
        return CreateDirectory(path);
    }
    
    // Basic file operations
    bool FileSystem::WriteFile(const std::string& path, const std::string& content) {
        std::string safePath = SanitizePath(path);
        
        // Make sure the directory exists
        std::string dirPath = GetDirectoryName(safePath);
        if (!dirPath.empty() && !EnsureDirectoryExists(dirPath)) {
            return false;
        }
        
        // Open the file for writing
        std::ofstream file(safePath, std::ios::out | std::ios::binary);
        if (!file.is_open()) {
            return false;
        }
        
        // Write the content
        file.write(content.c_str(), content.size());
        bool success = file.good();
        file.close();
        
        return success;
    }
    
    bool FileSystem::AppendToFile(const std::string& path, const std::string& content) {
        std::string safePath = SanitizePath(path);
        
        // Make sure the directory exists
        std::string dirPath = GetDirectoryName(safePath);
        if (!dirPath.empty() && !EnsureDirectoryExists(dirPath)) {
            return false;
        }
        
        // Open the file for appending
        std::ofstream file(safePath, std::ios::out | std::ios::app | std::ios::binary);
        if (!file.is_open()) {
            return false;
        }
        
        // Write the content
        file.write(content.c_str(), content.size());
        bool success = file.good();
        file.close();
        
        return success;
    }
    
    std::string FileSystem::ReadFile(const std::string& path) {
        std::string safePath = SanitizePath(path);
        
        // Check if the file exists
        if (!FileExists(safePath)) {
            return "";
        }
        
        // Open the file for reading
        std::ifstream file(safePath, std::ios::in | std::ios::binary);
        if (!file.is_open()) {
            return "";
        }
        
        // Read the entire file
        std::string content;
        file.seekg(0, std::ios::end);
        content.resize(file.tellg());
        file.seekg(0, std::ios::beg);
        file.read(&content[0], content.size());
        file.close();
        
        return content;
    }
    
    bool FileSystem::FileExists(const std::string& path) {
        std::string safePath = SanitizePath(path);
        
        #ifdef __OBJC__
        NSFileManager* fileManager = [NSFileManager defaultManager];
        NSString* nsPath = [NSString stringWithUTF8String:safePath.c_str()];
        
        BOOL isDir = NO;
        BOOL exists = [fileManager fileExistsAtPath:nsPath isDirectory:&isDir];
        return exists && !isDir;
        #else
        // Simple implementation for non-Objective-C
        struct stat st;
        return stat(safePath.c_str(), &st) == 0 && S_ISREG(st.st_mode);
        #endif
    }
    
    bool FileSystem::DirectoryExists(const std::string& path) {
        std::string safePath = SanitizePath(path);
        
        #ifdef __OBJC__
        NSFileManager* fileManager = [NSFileManager defaultManager];
        NSString* nsPath = [NSString stringWithUTF8String:safePath.c_str()];
        
        BOOL isDir = NO;
        BOOL exists = [fileManager fileExistsAtPath:nsPath isDirectory:&isDir];
        return exists && isDir;
        #else
        // Simple implementation for non-Objective-C
        struct stat st;
        return stat(safePath.c_str(), &st) == 0 && S_ISDIR(st.st_mode);
        #endif
    }
    
    bool FileSystem::Exists(const std::string& path) {
        std::string safePath = SanitizePath(path);
        
        #ifdef __OBJC__
        NSFileManager* fileManager = [NSFileManager defaultManager];
        NSString* nsPath = [NSString stringWithUTF8String:safePath.c_str()];
        
        return [fileManager fileExistsAtPath:nsPath];
        #else
        // Simple implementation for non-Objective-C
        struct stat st;
        return stat(safePath.c_str(), &st) == 0;
        #endif
    }
    
    bool FileSystem::DeleteFile(const std::string& path) {
        std::string safePath = SanitizePath(path);
        
        #ifdef __OBJC__
        NSFileManager* fileManager = [NSFileManager defaultManager];
        NSString* nsPath = [NSString stringWithUTF8String:safePath.c_str()];
        
        NSError* error = nil;
        BOOL success = [fileManager removeItemAtPath:nsPath error:&error];
        return success;
        #else
        // Simple implementation for non-Objective-C
        return remove(safePath.c_str()) == 0;
        #endif
    }
    
    bool FileSystem::RenameFile(const std::string& oldPath, const std::string& newPath) {
        std::string safeOldPath = SanitizePath(oldPath);
        std::string safeNewPath = SanitizePath(newPath);
        
        #ifdef __OBJC__
        NSFileManager* fileManager = [NSFileManager defaultManager];
        NSString* nsOldPath = [NSString stringWithUTF8String:safeOldPath.c_str()];
        NSString* nsNewPath = [NSString stringWithUTF8String:safeNewPath.c_str()];
        
        NSError* err# Let's check the exact text in ExecutionEngine.mm and then make the edit
grep -A5 "FileSystem::GetLogPath" source/cpp/ios/ExecutionEngine.mm

# Now let's create a fixed version with the proper namespace
cat > fix_execution_engine.sh << 'EOF'
#!/bin/bash
# Fix namespace issues in ExecutionEngine.mm

# Add iOS:: namespace to all FileSystem references
sed -i 's/FileSystem::GetLogPath/iOS::FileSystem::GetLogPath/g' source/cpp/ios/ExecutionEngine.mm
sed -i 's/FileSystem::WriteFile/iOS::FileSystem::WriteFile/g' source/cpp/ios/ExecutionEngine.mm

# Check other FileSystem references
sed -i 's/FileSystem::/iOS::FileSystem::/g' source/cpp/ios/ExecutionEngine.mm
